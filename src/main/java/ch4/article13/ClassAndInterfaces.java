/**
 *
 *                                              Классы и интерфейсы.
 *                                        Сводить к минимуму доступность классов
 *                                                      и членов.
 * Единственный чрезвычайно важный фактор, отличающий хорошо спроектированный модуль от неудачного - степень сокрытия
 * от других модулей его внутренних данных и других деталей реализации. Хорошо спроектированный модуль скрывает все детали
 * реализации, четко разделяя свой API и его реализацию. Модули взаимодействуют друг с другом серез свои API и ни один из
 * них не знает, какая обработка происходит внутри другого модуля - это инкапсуляция.
 * Главное правило сокрытия реализации заключается в том, что мы должны сделать каждый класс или член класса максимально
 * недоступным, насколько это возможно. Все методы в Интерфейсах по умочанию public, поэтому в классе, реализующем
 * интерфейс все методы должны тоже быть public.
 * Открытые поля в открытых классах должны появляться редко. Если поле не имеет модификатора final или имеет модификатор,
 * но ссылается на изменяемый объект, то, делая его открытым, мы упускаем возможность наложить ограничения на значения,
 * которые могут быть записаны в это поле. Отсюда простой вывод: классы с открытыми полями НЕ потокобезопасны. Кроме того
 * в устоявшейся системе изменение дизайна приложения с открытыми полями или методами чревато ошибками и поломками.
 * То же касается и к статическим полям, за исключением public static final констант. НО! Эти поля должны содержать либо
 * простые значения, либо ссылки на неизменяемые объекты. final-поле, ссылающееся на изменяемый объект, обладает теми же
 * недостатками, что и не-final-поле: ссылку изменить нельзя, но объект, на который она указывает еще как можно.
 * Пример дыры:
 *  public static final Thing[] VALUES = {...};
 * Выходов конкретно из такого положения - несколько. Во-первых, можно заменить открытый массив закрытым массивом и
 * открытым неизменяемым списком (так как сделать неизменяемым массив не получится(???)):
 *  private static final Thing[] PRIVATES = {...};
 *  public static final List<Thing> VALUES = Collections.unmodifiableList(Arrays.asList(VALUES));
 * Другая альтернатива - сделать геттер, который возвращает копию массива(если не жалко ресурсов).
 *
 * */

package ch4.article13;

public class ClassAndInterfaces {
}
