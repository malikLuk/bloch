/**
 *
 *                                                  Переопределение метода equals.
 * Простейший способ избежать проблем - вообще не переопределять метод equals(), тогда каждый объект будет эквивалентен
 * только самому себе. Когда мы переопределяем метод equals() - мы должны придерживаться общепринятых соглашений, вот
 * они:
 *  Рефлексивность - для любых ненулевых ссылок на значения x выражение x.equals(x) возвращает true. По сути, тут просто
 * говорится о том, что объект должен быть равен самому себе.
 *  Симметричность - для любых ненулевых ссылок на значения x и y выражение x.equals(y) должно возвращать true тогда и
 * только тогда, когда y.equals(x) возвращает true. Тут тоже просто, если объекты эквивалентны, то equals() должен
 * возвращать true при сравнении в любую сторону.
 *  Транзитивность - для любых ненулевых ссылок на значения x, y и z, если x.equals(y) возвращает true и y.equals(z)
 * возвращает true, то и выражение x.equals(z) тоже должно возвращать true. То есть, если первый объект равен второму,
 * а второй третьему, то первый объект тоже должен быть равен третьему.
 *  Непротиворечивость - для любых ссылок на значения x и y, если несколько раз вызвать x.equals(y), постоянно будет
 * возвращаться значение true, либо постоянно будет возвращаться значение false при условии, что никакая информация,
 * которая используется при сравнении объектов, не поменялась.
 *  Для любой ненулевой ссылки на значение x выражение x.equals(null) должно возвращать false.
 * В итоге, рецепт для создания качественного метода equals():
 * 1. Использовтаь оператор == для проверки, является ли аргумент ссылкой на указанный объект. Если это так - то сразу
 * возвращать true. Это всего лишь способ повысить производительность программы.
 * 2. Использовать instancef для проверки, имеет ли аргумент правильный тип. Если это не так - возвращаем false.
 * 3. Приводить аргумент к правильному типу (CastedType)o - эта операция должна следовать после проверки instanceof
 * 4. Сравнить все значимые поля в классе. Для простых типов, кроме float и double использовать ==. Для полей со ссылкой
 * на объект вызывать их equals(). Для float использовать Float.compare, для double - Double.compare. Особая процедура
 * сравнения float и double нужна потому, что существуют особые значение Float.NaN, -0.0f и аналогичные значения для
 * double. Для сравнения массивов использовать Array.equals (Java 1.5+).
 * 5. Переопределяя метод equals() - переопределяем и метод hashCode().
 * 6. Декларируя метод equals, не надо вписывать в его сигнатуру вместо Object другие типы. Представленный ниже пример
 * плохой:
 *  public boolean equals(MyClass o) {
 *      // some code
 *  }
 * Проблема здесь в том, что этот метод не переопределяет(Override) метод Object.equals, чей аргумент имеет тип Object,
 * а перегружает его(Overload).
 *
 * */

package ch3.article8;

public class EqualsOverride {

    static Object k = new Object();

    public static void main(String[] args) {
        System.out.println(k instanceof Object);
    }


}
