/**
 *
 *                                      Синхронизация доступа к общим ресурсам.
 * Использование synchronized дает гарантию, что в данный момент времени некий оператор или блок будет выполняться
 * только в одном потоке. Многие программисты рассматривают синхронизацию лишь как средство блокировки потоков, которое
 *  не позволяет одному потоку наблюдать объект в промежуточном состоянии, пока тот модифицируется другим потоком. Такая
 *  точка зрения верна, но не отражает всей картины. Без синхронизации изменения в одном потоке не видны другому. Каждый
 *  поток, попадая в синхронизированный блок, видит результат работы всех предыдущих потоков в этом блоке. Спецификация
 *  Java дает гарантию, что чтение и запись отдельной переменной, если это НЕ переменная long или double, являются
 *  атомарными операциями. Другими словами, гарантировано, что при чтении переменной (кроме long и double) будет возвращаться
 *  значение, которое было записано в эту переменную одним из потоков даже без синхронизации. Мы слышали о том, что для
 *  повышения производительности при чтении и записи атомарных данных нужно избегать синхронизации. Это НЕПРАВИЛЬНЫЙ совет.
 *  Хотя свойство атомарности гарантирует, что при чтении атомарных данных поток не увидит случайного значения, нет
 *  гарантии, что значение, записанное одним потоком, будет увидено другим. Отсуствие синхронизации для доступа к общим
 *  ресурсам чревато очень серьзными последствиями, даже если ресурс имеет свойство атомарности. О чем идет речь. Рассмотрим
 *  задачу остановки одного потока из другого. Для этого обычно используется прием, который заключается в том, чтобы в
 *  одном потоке создать некое опрашиваемое поле, значение которого по умолчанию false, но может быть установлено true
 *  другим потоком, для указания, что первый поток должен остановить сам себя. Такое поле, как правило, имеет тип boolean.
 *  Поскольку чтение и запись такого поля атомарны, то у программистов появляется соблазн предоставить ему доступ без
 *  синхронизации: см метод main(). Может показаться, что программа отработает секунду и остановится:
 *      TimeUnit.SECONDS.sleep(1);
 *      stopRequested = true;
 * но это не так. Поток backgroundThread неизвестно когда увидит, что переменна stopRequested стала true и, следовательно,
 * неизвестно когда остановится. Так как volatile мы сейчас не рассматриваем, то решить нашу проблему можно следующим
 * образом: методы requestStop() и isStopRequested(). Видно, что синхронизированы и метод чтения и метод записи. По
 * отдельности от их синхронизации толку бы не было. Лучшей альтернативой, конечно же, было бы объявить переменную
 * stopRequested как volatile. Но использовать volatile нужно с осторожностью. Например, если у нас есть переменная
 * volatile int intVar; и мы хотим заинкрементить ее - то это надо делать в синхронизированном блоке, так как операция
 * intVal++ НЕ атомарная и volatile тут не спасет. Операция инкремента состоит из трех операций: чтение старого значение,
 * увеличение его на 1, запись нового значения. И следовательно, переменная intVal может быцть перехвачена другим потоком
 * еще до записи нового значения и два или более потоков могут считать одно и тоже занчение и заинкрементить его. И, если
 * на то пошло, то лучше использовать AtomicLong. Главный посыл статьи - по максимуму не делать общими изменяемые данные,
 * либо делать общими НЕизменяемые данные, либо вообще, изменяемые данные держать строго в одном потоке.
 *
 * */


package ch10.article66;

import java.util.concurrent.TimeUnit;

public class Synchronizers {

    private static boolean stopRequested;

    private static synchronized void requestStop() {
        stopRequested = true;
    }

    private static synchronized boolean isStopRequested() {
        return stopRequested;
    }

    public static void main(String[] args) throws InterruptedException {
        Thread backgroundThread = new Thread(() -> {
            int i = 0;
            while (!isStopRequested()){
                i++;
            }
        });

        backgroundThread.start();
        TimeUnit.SECONDS.sleep(5);
        requestStop();
    }


}
