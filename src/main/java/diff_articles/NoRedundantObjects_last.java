/**
 *
 * Избегать создания лишних объектов.
 * Зачастую целесообразно использовать один объект вместо создания нового, функционально эквивалентного объекта, всякий раз, когда
 * он становится необходимым. Повторное исопльзование и быстрее и элегантнее. Неименяемый объект всегда можно использовать повторно.
 * Вот экстремальный пример того, как не надо поступать:
 *  String s = new String("bikini"); // не делать так
 * Такой код создает новый инстанс String при каждом исполнении, при том, что ни одно из этих созданий не является необходимым. Аргументом
 * конструктора String("bikini") является сам инстанс String, функционально идентичный всем объектам, создаваемым таким конструктором. То
 * есть "bikini" - это уже созданная строка и незачем передавать ее в констурктор другой строки. Если бы это происходило в цикле - то были
 * бы созданны миллионы объектов String("bikini"), хотя можно было бы обойтись одним String = "bikini".
 * Можно также избежать создания ненужных объектов, если в неизменяемом классе, имеющем конструкторы И статические фабричные методы пользоваться
 * именно последними. Например, в классе Boolean есть фабричный метод Boolean.valueOf(String), который возращает существующий в самом классе
 * Boolean инстан TRUE или FALSE. И метод Boolean.valueOf(String) предпочтительнее, чем конструктор new Boolean(String), который даже вырезали
 * из Java 9. Конструктор обязан создавать новый объект при каждом вызове, в то время как фабричный метод может возвращать уже заготовленное
 * значение.
 * Создание одних объектов оказывается гораздно более дорогим, чем создание других. Если многократно требуется дорогой объект, возможно, имеет
 * смысл кэшировать его для повторного использования. К сожалению, не всегда очевидно, "дорогой" ли объект. Предположим, мы хотим написать
 * метод, который определяет, является ли строка корректным римским числом. Вот он - isRomanNumeral. Проблема в том, что этот метод опирается
 * на String.matches - это простейший спобос проверки соответствует ли строка регулярному выражению, он не подходит для многократного использования
 * в ситуациях, критичных в смысле производительности. Проблема в том, что String.matches внутри себя создает экземпляр  Pattern для регулярного
 * выражения и использует его только один раз, после чего он утилизируется сборщиком. Создание экземпляра Pattern достаточно дорогостоящее, так
 * как требует компиляции регулярного выражения в конечный автомат. Для повышения производительности мы сами можем сами скомпилировать регулярное
 * выражение в инстанс Pattern, который является неизменяемым, и повторно использовать тот же инстанс для каждого вызова isRomanNumeralWithPattern,
 * как в примере ниже. Там происходит все тоже самое, что и в кишках s.matches("^(?=.)M*(C[MD]|D?C{0,3})(X[CL]|L?X{0,3})(I[XV]|V?I{0,3})$");.
 * В среднем, улучшенная версия работает в 6,5 раза быстрее.
 * Рассмотрим случай адаптеров. Адаптер представляет собой объект, котоырй выполняет делегирование другому объекту, обеспечивая альтернативный
 * интерфейс. Поскольку адаптер не имеет состояния, помимо состояния объекта, которому выполняется делегирование, нет и необходимости создавать
 * более одного экземпляра конкретного адаптера для заданного объекта. Пример ненужно создания новых экземпляров является метод keySet(),
 * интерфейса Map. Так и не понятно почему. Еще одним таким примером является автоупаковка (autoboxing), которая позволяет программисту смешивать
 * примитивные и упакованные типы, автоматически упаковывая и распаковывая их при необходимости. Рассмотрим пример низкой производительности:
 * вычислим сумму всех положительных чисел из диапазона int - метод sum(). Этот метод дает правильный ответ, но она гораздо медленнее, чем должна
 * быть. Переменная sum объявлена как Long, вместо long, а это означает, что программа создает около 2^31 степени ненужных экземпляров Long (примерно
 * по одному для каждого добавления long i к Long sum). Изменение объявления sum из Long в long уменьшает время выполнения примерно в 10 раз. В
 * принципе, урок ясен, надо отдавать предпочтение примитивным, а не упакованным типам и следить за непреднамеренной автоупаковкой.
 * Классическим примером тяжелого объекта, который оправдывает свое существование является объект подключения к базе данных.
 *
 * */

package diff_articles;

import java.util.regex.Pattern;

public class NoRedundantObjects_last {

    public static void main(String[] args) {
        System.out.println(isRomanNumeral("VXIII"));
        System.out.println(isRomanNumeral("XVIII"));
    }

    private static long sum() {
        Long sum = 0L;
        for (long i = 0; i < Integer.MAX_VALUE; i++) {
            sum+=i;
        }
        return sum;
    }

    // неправильно
    static boolean isRomanNumeral(String s) {
        return s.matches("^(?=.)M*(C[MD]|D?C{0,3})(X[CL]|L?X{0,3})(I[XV]|V?I{0,3})$");
    }

    // правильно
    private static final Pattern ROMAN = Pattern.compile("^(?=.)M*(C[MD]|D?C{0,3})(X[CL]|L?X{0,3})(I[XV]|V?I{0,3})$");

    static boolean isRomanNumeralWithPattern(String s) {
        return ROMAN.matcher(s).matches();
    }

}
