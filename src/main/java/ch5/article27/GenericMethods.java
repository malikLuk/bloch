/**
 *
 *                                              Поддерживать обобщенные методы.
 * Методы, подобно классам, тоже получают свои преимущества от обобщения. Статические служебные методы - хорошие кандидаты
 * для этого. Все алгоритмические методы в Collection (такие как binarySearch и Sort) обощены. Написание обощенных методов
 * схоже с написанием обощенных типов. Рассмотрим на примере метода union. Этот метод скомпилируется с двумя предупреждениями.
 * ДЛЯ ТОГО, ЧТОБЫ ИСПРАВИТЬ ЭТИ ПЕРДУПРЕЖДЕНИЯ И СДЕЛАТЬ МЕТОД БЕЗОПАСНЫМ ДЛЯ ТИПОВ НУЖНО ИЗМЕНИТЬ ДЕКЛАРИРОВАНИЕ МТЕОДА
 * ТАК, ЧТОБЫ ОН ДЕКЛАРИРОВАЛ ПАРАМЕТРЫ, ПЕРДСТАВЛЯЮЩИЕ ТИПЫ ЭЛЕМЕНТА ДЛЯ ТРЕХ МНОЖЕСТВ (ДВА АРГУМЕНТА И ВОЗВРАЩАЕМОЕ ЗАНЧЕНИЕ).
 * Список параметров, который их декларирует, лежит между модификатором метода и  его возвращаемым типом. В нашем примере
 * списком параметров будет <E>, так как все множества одного типа, а возврщаться будет Set<E>. См. метод unionGeneric.
 * Статический обобщенный синглтон - шаблон проектирования, позволяет нам создать неизменяемы объекты различных типов.
 * Доупскается, чтобы параметр типа был ограничен выражением, включающим в себя этот самый парметр - это называется
 * Рекурсивным Ограничение Типа. Наиболее часто оно используется с интерфейсом Comparable<T>. Например, запись вида
 *  public interface Comparable<T> {
 *      int compareTp(T o);
 *  }
 * означает, что параметр типа T определяет тип, с которым можно сравнить реализацю элементовсамого типа Comparable. Если
 * короче, то ограничение вида <T extends Comparable<T>> можно прочитать как "для каждого типа Т, который может быть
 * сопоставлен с самим собой" или "для каждого типа, который реализует Comparable этого самого типа". Приведем пример,
 *  который надо использовать для рассчета масимального значения списка, согласно натуральному порядку его элементов.
 *  Метод max()
 *
 * */

package ch5.article27;

import java.util.*;

public class GenericMethods {

    // Возвращает максимальное значение из списка и использует
    // рекурсивное ограничение типа (<T extends Comparable<T>>)
    public static <T extends Comparable<T>> T max(List<T> list) {
        Iterator<T> i = list.iterator();
        T result = i.next();
        while (i.hasNext()) {
            T t = i.next();
            if (t.compareTo(result) > 0) {
                result = t;
            }
        }
        return result;
    }

    public static void main(String[] args) {
        System.out.println(max(Arrays.asList(4,5,6,7,1,10)));
    }

    @SuppressWarnings("unchecked")
    public static Set union(Set s1, Set s2) {
        Set result = new HashSet(s1);
        result.addAll(s2);
        return result;
    }

    public static <E> Set<E> unionGeneric(Set<E> s1, Set<E> s2) {
        Set<E> result = new HashSet<E>(s1);
        result.addAll(s2);
        return result;
    }

}
