/**
 *
 *                                              Поддерживать обобщенные методы.
 * Методы, подобно классам, тоже получают свои преимущества от обобщения. Статические служебные методы - хорошие кандидаты
 * для этого. Все алгоритмические методы в Collection (такие как binarySearch и Sort) обощены. Написание обощенных методов
 * схоже с написанием обощенных типов. Рассмотрим на примере метода union. Этот метод скомпилируется с двумя предупреждениями.
 * ДЛЯ ТОГО, ЧТОБЫ ИСПРАВИТЬ ЭТИ ПЕРДУПРЕЖДЕНИЯ И СДЕЛАТЬ МЕТОД БЕЗОПАСНЫМ ДЛЯ ТИПОВ НУЖНО ИЗМЕНИТЬ ДЕКЛАРИРОВАНИЕ МТЕОДА
 * ТАК, ЧТОБЫ ОН ДЕКЛАРИРОВАЛ ПАРАМЕТРЫ, ПЕРДСТАВЛЯЮЩИЕ ТИПЫ ЭЛЕМЕНТА ДЛЯ ТРЕХ МНОЖЕСТВ (ДВА АРГУМЕНТА И ВОЗВРАЩАЕМОЕ ЗАНЧЕНИЕ).
 * Список параметров, который их декларирует, лежит между модификатором метода и  его возвращаемым типом. В нашем примере
 * списком параметров будет <E>, так как все множества одного типа, а возврщаться будет Set<E>. См. метод unionGeneric.
 * Статический обобщенный синглтон - шаблон проектирования, позволяет нам создать неизменяемы объекты различных типов.
 * Доупскается, чтобы параметр типа был ограничен выражением, включающим в себя этот самый парметр - это называется
 * Рекурсивным Ограничение Типа. Наиболее часто оно используется с интерфейсом Comparable<T>. Например, запись вида
 *  public interface Comparable<T> {
 *      int compareTp(T o);
 *  }
 * означает, что параметр типа T определяет тип, с которым можно сравнить реализацю элементовсамого типа Comparable. Если
 * короче, то ограничение вида <T extends Comparable<T>> можно прочитать как "для каждого типа Т, который может быть
 * сопоставлен с самим собой" или "для каждого типа, который реализует Comparable этого самого типа".
 *
 * */

package ch5.article27;

import java.util.HashSet;
import java.util.Set;

public class GenericMethods {

    public static void main(String[] args) {

    }

    public static Set union(Set s1, Set s2) {
        Set result = new HashSet(s1);
        result.addAll(s2);
        return result;
    }

    public static <E> Set<E> unionGeneric(Set<E> s1, Set<E> s2) {
        Set<E> result = new HashSet<E>(s1);
        result.addAll(s2);
        return result;
    }

}
