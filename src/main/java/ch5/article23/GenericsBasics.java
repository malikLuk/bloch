/**
 *
 *                                          Средства обобщенного программирвоания.
 *                                                          Дженерики.
 * В Java 1.5 пояаились средства обобщенного программирования. До их появления, нужно было передавать все объекты из
 * коллекции, и, если кто-то вставит обьъект неправильного типа, то программа рухнет. С помощью же дженериков, мы даем
 * компилятору указания, какие типы объектов разрешены в каждой конкретной коллекции. Компилятор автоматизирует передачу
 * объектов и на этапе компиляции говорит нам о том, что мы пытаемся вставить объект неверного типа. Благодаря этмоу,
 * программы становятся не только более типобезопасными, но и более "чистыми".
 * Для начала несколько терминов. Класс или интерфейс, декларация которого содержит один или более Параметров Типа (Type
 * Parameters) является обобщенным(generic) классом или интерфейсом. Например, у интерфейса List есть один параметр типа
 * E (List<E>), представляющий тип элемента списка. Обобщенные классы и интерфейсы известны под общим названием Обобщенные
 * типы (Generic Types).
 * Каждый обощенный тип определяет набор Параметризованных Типов (parametrized types), который состоит из наименования
 * класса или интерфейса, после которых следуют угловые скобки, в которых записываются Параметры Типа. Наример, тип с
 * парметрами, представлющий список строк - это List<String>, где String - Это параметр типа, соответсвующий E в определении
 * списка List<E>. Также, существуют и Необработанные Типы, которые являются наименованием обощенного типа без параметра
 * типа. То есть, необработанным типом для List<E> будет просто List. На практике необработанный тип List ведет себя так,
 * как вел себя List до появления дженериков.
 *  До релиза 1.5 это было типичной делкарацией коллекции:
 *      //Коллекция по идее должна содержать только экземпляры Stamp (марки)
 *      private final Collection stamps = ... ;
 *      //Но если мы случайно добавим в эту коллекцию Coin (монету), то компилятор это сожрет и выполнит
 *      stamps.add(new Coin(...));
 *      // Ошибки не будет до тех пор, пока мы не станем извлекать монетку (Coin) из коллекции марок (stamps)
 *      // PS. Никогда так не делать
 *      for (Iterator i = stamps.iterator(); i.hasNext();) {
 *          Stamp s = (Stamp) i.next(); // Throws ClassCastException
 *          ... // Do something with stamp
 *      }
 *      // И теперь, когда программа свалится в ошибкой, нам придется искать - а где мы ее допустили, так как она
 *      // допущена задолго до того места, где свалилось приложение.
 *
 *      // С использованием же дженериков мы решаем эту проблему, так как код, в котором Coin добавляется в коллекцию
 *      // Stamp'ов просто не скомпилируется
 *      private final Collection<Stamp> stamps = ... ;
 *      // Благодаря такой декларации компилятор знает, что stamps должна содержать только экземпляры Stamp
 *      // Еще одно преимущество в том, что нам не надо приводить типы к Stamp при итерировании коллекции
 * Кое что интересно представленно ниже в методе unsafeAdd. Здесь в аргументе функции исполбзуется необработанный тип
 * List, а не параметризованный List<String>. Здесь компилятор помечает list.add(o) как небезопасный способ, а уже при
 * компиляции валится ClassCastException.
 * Возможно, у нас появится задача написать метод, который работает с двумя коллекциями разных типов и возвращает
 * количество элементов, которые имеют между собой некий рьщий признак. Обобщенное программирование предоставляет нам
 * типобезопасную возможность реализовать такой метод - называется "несвязный тип подстановки" или unbound wildcard type.
 * Если мы хотим использовать обобщенные типы, но нам не важны актуальные типы подстановок (это то, что в "<>"), то можно
 * просто использовать вместо них знак вопроса. Например, несвязным типом подстановки для обобщенного типа Set<E> будет
 * Set<?> - это наиболее общий тип Set с параметрами, способный содержать любой набор. Пример метода - numElementInCommon.
 * Вариант с Collection<?> тоже типобезопасен, мы не можем добавить в такую коллекцию что-либо, кроме null, а вот использовать
 * ее, как аргумент метода - можем.
 * Итого:
 *      Set<Object> - это тип с параметрами, который может содержать объекты любого типа
 *      Set<?> - это тип подстановки, который может содержать только объекты некоторого неизместного типа
 *      Set - необработанный тип, который лишает нас возможности использовать систему обобщенных типов.
 *      Первые два безопасны, а последний - нет.
 * Термины
 *      Тип с параметрами               -               List<String>
 *      Актуальный параметр типа        -               String
 *      Обощенный тип                   -               Set<E>
 *      Формальный параметр типа        -               E
 *      Несвязанный тип подстановки     -               List<?>
 *      Необработанный тип              -               List
 *      Связанный параметр типа         -               <E extends Number>
 *      Рекурсивная связка типа         -               <T extends Comparable<T>>
 *      Связанный тип подстановки       -               List<? extends Number>
 *      Метка типа                      -               String.class
 *
 * */

package ch5.article23;

import java.util.ArrayList;
import java.util.List;
import java.util.Set;

public class GenericsBasics {

    public static void main(String[] args) {
        List<String> list = new ArrayList<String>();
        unsafeAdd(list, new Integer(42));
        String s = list.get(0);


    }

    private static void unsafeAdd(List list, Object o) {
        list.add(o);
    }

    static int numElementInCommon(Set<?> s1, Set<?> s2) {
        int result = 0;
        for (Object o1 : s1) {
            if (s1.contains(o1)) {
                result++;
            }
        }
        return result;
    }

}
