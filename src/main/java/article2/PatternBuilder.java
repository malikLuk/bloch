/**
 *
 *                                              Исползоваьть шаблон Builder, когда
 *                                         приходится иметь дело с большим количеством
 *                                                   параметров конструктора.
 * У конструткоров и статических меодов есть одно общее ограничение: они плохо масштабируют большое количество необязательных
 * параметров. Рассмотрим случай: класс, представляющий собой этикетку с информацией о питательности на упаковке с продуктами
 * питания. На этих этикетках есть несколько обязательных полей - размер порции, кол-во порций в упаковке, калорийность, а
 * также ряд неоьязательных параметров - общее содержание жиров, содержание насыщенных жиров, холестерина, натрия и т д.
 * У большинства продуктов не нулевыми будут только несколько из этих необязательных полей, а то и вовсе, все нулевые.
 * Какой конструктор или методы нужно использовать для написания данного класса? Непонятно, так как чем больше входных
 * параметров - тем труднее писать код и еще труднее его читать и поддерживать. Можно использовать стиль JavaBeans, когда
 * создаем объект вызывая конструктор без параметров, а потом сеттерами доставляем, что нужно. Но шаблон JavaBeans тоже
 * не лишен недостатков. Поскольку его конструкция разделена между несколькими вызовами, пока все нужные поля не засеттились -
 * объект находится в неустойчивом состоянии и можно случайно обратиться к объекту в тот момент, когда у него заполнены еще
 * не все поля.
 * К счастью - есть решение. Оно является одной из форм шаблона "конструтор". Вместо непосредственного создания желаемого
 * объекта клиент вызывает конструктор(или статический метод) со всеми необходимыми параметрами и получает объект Builder.
 * Затем клиент вызывает сеттеры на этом объекте для установки всех интересующих параметров. Наконец, клиент вызывает метод
 * build() для генерации объекта, который будет являться неизменным. "Конструткор" является статическим внутренним классом
 * в классе, который он создает. Ниже описано, как это выглядит.
 * Следует обратить внимание, что PatternBuilder является неизменным и что все значения параметров по умолчанию находятся
 * в одном месте. Сеттеры объекта Строитель возвращают сам этот Строитель. поэтому вызовы можно объединить в цепочку.
 * Как это выглядит - ниже. То есть мы по мере надобности просто дописываем нужные значения через билдер и  в конце вызываем
 * build(). 
 * Еще одно небольшое преимущество Строителя заключается в том, что можно использовать несколько параметров vararg (аргументы
 * переменной длины). Но есть ограничения - один параметр vararg на один сеттер. Можено также использовать Строитель с
 * дженериками. Например, нашу констуркцию можно заменить на Builder<PatternBuilder>. Или же в самой Java есть интерфейс
 *
 *  @FunctionalInterface
 *  public interface Builder<T> {
 *      T build();
 *  }
 *
 * В итоге, можно сказать, что Строитель - это хороший выбор при проектировании классов, у чьих конструкторов много параметров.
 * Особенно, если большинство из них не являются обязательными. Код намного легче читать, и искользование Строителя
 * безопаснее, чем использование JavaBeans(конструктор без параметров и сеттеры нужных параметров).
 *
 * */


package article2;

public class PatternBuilder {

    private final int servingSize;
    private final int servings;
    private final int calories;
    private final int fat;
    private final int sodium;
    private final int carbo;

    public static class Builder {

        // Обязательные параметры
        private final int servingSize;
        private final int servings;
        // Необязательные параметры
        private int calories = 0;
        private int fat = 0;
        private int sodium = 0;
        private int carbo = 0;

        public Builder(int servingSize, int servings) {
            this.servingSize = servingSize;
            this.servings = servings;
        }

        public Builder calories(int val) {
            calories = val;
            return this;
        }

        public Builder fat(int val) {
            fat = val;
            return this;
        }

        public Builder sodium(int val) {
            sodium = val;
            return this;
        }

        public Builder carbo(int val) {
            carbo = val;
            return this;
        }

        public PatternBuilder build() {
            return new PatternBuilder(this);
        }

    }

    private PatternBuilder(Builder builder) {
        servingSize = builder.servingSize;
        servings = builder.servings;
        calories = builder.calories;
        fat = builder.fat;
        sodium = builder.sodium;
        carbo = builder.carbo;
    }

    public static void main(String[] args) {
        PatternBuilder object = new Builder(240,8).calories(100).sodium(500).build();
    }

}
